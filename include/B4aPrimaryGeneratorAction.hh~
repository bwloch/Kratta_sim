#ifndef B4aPrimaryGeneratorAction_h
#define B4aPrimaryGeneratorAction_h 1

#include "G4VUserPrimaryGeneratorAction.hh"
#include "B4aPrimaryGeneratorAction.hh"

#include "Randomize.hh"
#include <iostream>
#include <fstream>

#include "globals.hh"


class G4ParticleGun;
class G4Event;
class B4aDetectorConstruction;
class G4ParticleDefinition;
class Ranlux64Engine;
class RandFlat;

class B4aPrimaryGeneratorAction : public G4VUserPrimaryGeneratorAction
{
public:
  B4aPrimaryGeneratorAction(B4aDetectorConstruction*);    
  virtual ~B4aPrimaryGeneratorAction();

  virtual void GeneratePrimaries(G4Event* event);
  
  G4double bt1,bt2,bt3,t1,t2,t3,fi1,fi2,fi3;
  G4float bt1_mev,th,thl[70],ds[70],ay[70],ap1[70],ap2[70],t21,ap3[70];
  G4float sig[20][20][15][200],ay0[20][20][15][200];
    //axx[20][20][15][200],ayy[20][20][15][200],axn[20][20][15][200],
    //	  axy[20][20][15][200],axz[20][20][15][200];

    G4int aj1bx, aj1by, ajbz, aj1theta, aj2theta, aj1phi, aj2phi, aj1ekin, aja10,
    	aja20, aju, ajcs1, ajcs02, aj1r1, aj1r2, npd_choice, icros ;
    G4double bfwhmx, bfwhmy, bt, pz, pzz, themin, themax, themin2, themax2, fimin,fimax;
    G4double tXplace, tYplace,tZplace,thigh;
    G4double generator_min, generator_max;
  //ifstream *file;
  G4double vertex[3];    
  G4double GetVertexX(void){return vertex[0];} ;
  G4double GetVertexY(void){return vertex[1];} ;
  G4double GetVertexZ(void){return vertex[2];} ;


  inline static G4double* GetStartEnergy (G4double en1 = -1., G4double en2 = -1., G4double en3 = -1.)
    {
      static G4double tes1[3];
      if (en1 != -1.)
      {
        tes1[0] = en1;
	tes1[1] = en2;
	tes1[2] = en3;
      }
      return tes1;
    };

    inline static G4double* GetStartAngleTheta (G4double ang1 = -1., G4double ang2 = -1., G4double ang3 = -1.)
    {
      static G4double tes2[3];
      if (ang1 != -1.)
      {
        tes2[0] = ang1;
	tes2[1] = ang2;
	tes2[2] = ang3;
      }
      return tes2;
    };

    inline static G4double* GetStartAnglePhi (G4double ang1 = -1., G4double ang2 = -1., G4double ang3 = -1.)
    {
      static G4double tes3[3];
      if (ang1 != -1.)
      {
        tes3[0] = ang1;
	tes3[1] = ang2;
	tes3[2] = ang3;
      }
      return tes3;
    };

    inline static G4double* GetStartPosition (double v1 = 0., double v2 = 0., double v3 = 0.)
    {
      static G4double tes3[3];
          if ((v1 != 0.)||(v2 != 0.)||(v3 != 0.))
      {
        tes3[0] = v1;	tes3[1] = v2;	tes3[2] = v3;
      }
      return tes3;
    }

    inline static G4int ProcNb(G4int num = 10)
    {
      static G4int temp;
      if (num != 10) temp = num;
      return temp;
    };

    inline static G4int GetChoice (G4int num = 10)
    {
      static G4int temp;
      if (num != 10) temp = num;
      return temp;
    };


  // set methods
  //void SetRandomFlag(G4bool value);

private:
  //G4ParticleGun*  fParticleGun; // G4 particle gun

  G4ParticleGun* particleGun1;		//part 1
  G4ParticleGun* particleGun2;		//part 2
  
  G4ParticleDefinition *particleDefinition;
  B4aDetectorConstruction* myDetector;
  
  void RandomInit(G4int =2);			//generators initialization
  G4double RandomGauss(G4double, G4double =0, G4double =1);	// gauss
  G4double RandomFlat (G4double, G4double =0, G4double =1);	// flat
  void Pos(void);				//generate vertex position

    G4double* elastic(G4double*);
    G4double* ugelast(G4double*);
    G4double* upunif(G4double*);

    void ugelast_read(void);
    void break_read(void);

    G4double gelkin(G4double,G4double*,G4double*);  // elastic kinematics
    
    G4double momentum[9];
  
    G4double p_mass, He3_mass;
    
   
    //CLHEP::RandFlat* GaussDist[2];
    CLHEP::RandGauss* GaussDist[2];
    
    CLHEP::RandFlat* FlatDist[9];
   


};



#endif


